============================= test session starts ==============================
platform linux2 -- Python 2.7.3 -- pytest-2.2.3
collecting ... collected 13 items

test_Album.py ......
test_Song.py EEEEEEE

==================================== ERRORS ====================================
___ ERROR at setup of TestWriteSong.TestReadBundle.test_read_altered_artist ____

self = <test_Song.TestReadBundle instance at 0x90c6ecc>
request = <FuncargRequest for <Function 'test_read_altered_artist'>>

    def pytest_funcarg__song(self, request):
        """Dependency Injection: Song"""
        return request.cached_setup(self.setup_song,
                self.teardown_song,
>               scope='class')

test_Song.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FuncargRequest for <Function 'test_read_altered_artist'>>
setup = <bound method TestReadBundle.setup_song of <test_Song.TestReadBundle instance at 0x90c6ecc>>
teardown = <bound method TestReadBundle.teardown_song of <test_Song.TestReadBundle instance at 0x90c6ecc>>
scope = 'class', extrakey = None

    def cached_setup(self, setup, teardown=None, scope="module", extrakey=None):
        """ Return a testing resource managed by ``setup`` &
            ``teardown`` calls.  ``scope`` and ``extrakey`` determine when the
            ``teardown`` function will be called so that subsequent calls to
            ``setup`` would recreate the resource.
    
            :arg teardown: function receiving a previously setup resource.
            :arg setup: a no-argument function creating a resource.
            :arg scope: a string value out of ``function``, ``class``, ``module``
                or ``session`` indicating the caching lifecycle of the resource.
            :arg extrakey: added to internal caching key of (funcargname, scope).
            """
        if not hasattr(self.config, '_setupcache'):
            self.config._setupcache = {} # XXX weakref?
        cachekey = (self._currentarg, self._getscopeitem(scope), extrakey)
        cache = self.config._setupcache
        try:
            val = cache[cachekey]
        except KeyError:
>           val = setup()

../lib/python2.7/site-packages/_pytest/python.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_Song.TestReadBundle instance at 0x90c6ecc>

    def setup_song(self):
        """Setup: Open edited dummy song"""
>       return Song.Song(TestWriteSong.song)

test_Song.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x90c6fac>, path = None, fields = None

    def __init__(self, path, fields=None):
        """Instantiate Song object
    
            Requires a filepath for a song file to represent and accepts an
            optional fields parameter for specifying the songs fields. If
            such a dictionary is passed, it will be used exclusively to fill
            the field tag data of the Song instance.
    
            If no additional fields are specified, the Song instance's fields
            will be populated by metadata from the audio file.
    
            Compatible files: flac (*.flac), ogg vorbis (*.ogg)
            """
    
        self.path = path
        self._song_file = None
>       self._connect_to_file()

../Song.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x90c6fac>

    def _connect_to_file(self):
        """Opens a file and determines type. File will be opened
            (if compatible) with codec and metadata will be read in.
            """
        def determine_type():
            """Determine codec to use in opening file depending on extension"""
            extension = os.path.splitext(self.path)[-1][1:]
            return Song._supported_filetypes[extension]
    
>       song_type = determine_type()

../Song.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def determine_type():
        """Determine codec to use in opening file depending on extension"""
>       extension = os.path.splitext(self.path)[-1][1:]

../Song.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None

>   ???

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/posixpath.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None, sep = '/', altsep = None, extsep = '.'

>   ???
E   AttributeError: 'NoneType' object has no attribute 'rfind'

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/genericpath.py:91: AttributeError
____ ERROR at setup of TestWriteSong.TestReadBundle.test_read_altered_album ____

self = <test_Song.TestReadBundle instance at 0x8fdee4c>
request = <FuncargRequest for <Function 'test_read_altered_album'>>

    def pytest_funcarg__song(self, request):
        """Dependency Injection: Song"""
        return request.cached_setup(self.setup_song,
                self.teardown_song,
>               scope='class')

test_Song.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FuncargRequest for <Function 'test_read_altered_album'>>
setup = <bound method TestReadBundle.setup_song of <test_Song.TestReadBundle instance at 0x8fdee4c>>
teardown = <bound method TestReadBundle.teardown_song of <test_Song.TestReadBundle instance at 0x8fdee4c>>
scope = 'class', extrakey = None

    def cached_setup(self, setup, teardown=None, scope="module", extrakey=None):
        """ Return a testing resource managed by ``setup`` &
            ``teardown`` calls.  ``scope`` and ``extrakey`` determine when the
            ``teardown`` function will be called so that subsequent calls to
            ``setup`` would recreate the resource.
    
            :arg teardown: function receiving a previously setup resource.
            :arg setup: a no-argument function creating a resource.
            :arg scope: a string value out of ``function``, ``class``, ``module``
                or ``session`` indicating the caching lifecycle of the resource.
            :arg extrakey: added to internal caching key of (funcargname, scope).
            """
        if not hasattr(self.config, '_setupcache'):
            self.config._setupcache = {} # XXX weakref?
        cachekey = (self._currentarg, self._getscopeitem(scope), extrakey)
        cache = self.config._setupcache
        try:
            val = cache[cachekey]
        except KeyError:
>           val = setup()

../lib/python2.7/site-packages/_pytest/python.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_Song.TestReadBundle instance at 0x8fdee4c>

    def setup_song(self):
        """Setup: Open edited dummy song"""
>       return Song.Song(TestWriteSong.song)

test_Song.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x8fdef6c>, path = None, fields = None

    def __init__(self, path, fields=None):
        """Instantiate Song object
    
            Requires a filepath for a song file to represent and accepts an
            optional fields parameter for specifying the songs fields. If
            such a dictionary is passed, it will be used exclusively to fill
            the field tag data of the Song instance.
    
            If no additional fields are specified, the Song instance's fields
            will be populated by metadata from the audio file.
    
            Compatible files: flac (*.flac), ogg vorbis (*.ogg)
            """
    
        self.path = path
        self._song_file = None
>       self._connect_to_file()

../Song.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x8fdef6c>

    def _connect_to_file(self):
        """Opens a file and determines type. File will be opened
            (if compatible) with codec and metadata will be read in.
            """
        def determine_type():
            """Determine codec to use in opening file depending on extension"""
            extension = os.path.splitext(self.path)[-1][1:]
            return Song._supported_filetypes[extension]
    
>       song_type = determine_type()

../Song.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def determine_type():
        """Determine codec to use in opening file depending on extension"""
>       extension = os.path.splitext(self.path)[-1][1:]

../Song.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None

>   ???

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/posixpath.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None, sep = '/', altsep = None, extsep = '.'

>   ???
E   AttributeError: 'NoneType' object has no attribute 'rfind'

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/genericpath.py:91: AttributeError
____ ERROR at setup of TestWriteSong.TestReadBundle.test_read_altered_title ____

self = <test_Song.TestReadBundle instance at 0x8fd842c>
request = <FuncargRequest for <Function 'test_read_altered_title'>>

    def pytest_funcarg__song(self, request):
        """Dependency Injection: Song"""
        return request.cached_setup(self.setup_song,
                self.teardown_song,
>               scope='class')

test_Song.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FuncargRequest for <Function 'test_read_altered_title'>>
setup = <bound method TestReadBundle.setup_song of <test_Song.TestReadBundle instance at 0x8fd842c>>
teardown = <bound method TestReadBundle.teardown_song of <test_Song.TestReadBundle instance at 0x8fd842c>>
scope = 'class', extrakey = None

    def cached_setup(self, setup, teardown=None, scope="module", extrakey=None):
        """ Return a testing resource managed by ``setup`` &
            ``teardown`` calls.  ``scope`` and ``extrakey`` determine when the
            ``teardown`` function will be called so that subsequent calls to
            ``setup`` would recreate the resource.
    
            :arg teardown: function receiving a previously setup resource.
            :arg setup: a no-argument function creating a resource.
            :arg scope: a string value out of ``function``, ``class``, ``module``
                or ``session`` indicating the caching lifecycle of the resource.
            :arg extrakey: added to internal caching key of (funcargname, scope).
            """
        if not hasattr(self.config, '_setupcache'):
            self.config._setupcache = {} # XXX weakref?
        cachekey = (self._currentarg, self._getscopeitem(scope), extrakey)
        cache = self.config._setupcache
        try:
            val = cache[cachekey]
        except KeyError:
>           val = setup()

../lib/python2.7/site-packages/_pytest/python.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_Song.TestReadBundle instance at 0x8fd842c>

    def setup_song(self):
        """Setup: Open edited dummy song"""
>       return Song.Song(TestWriteSong.song)

test_Song.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x8fd854c>, path = None, fields = None

    def __init__(self, path, fields=None):
        """Instantiate Song object
    
            Requires a filepath for a song file to represent and accepts an
            optional fields parameter for specifying the songs fields. If
            such a dictionary is passed, it will be used exclusively to fill
            the field tag data of the Song instance.
    
            If no additional fields are specified, the Song instance's fields
            will be populated by metadata from the audio file.
    
            Compatible files: flac (*.flac), ogg vorbis (*.ogg)
            """
    
        self.path = path
        self._song_file = None
>       self._connect_to_file()

../Song.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x8fd854c>

    def _connect_to_file(self):
        """Opens a file and determines type. File will be opened
            (if compatible) with codec and metadata will be read in.
            """
        def determine_type():
            """Determine codec to use in opening file depending on extension"""
            extension = os.path.splitext(self.path)[-1][1:]
            return Song._supported_filetypes[extension]
    
>       song_type = determine_type()

../Song.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def determine_type():
        """Determine codec to use in opening file depending on extension"""
>       extension = os.path.splitext(self.path)[-1][1:]

../Song.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None

>   ???

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/posixpath.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None, sep = '/', altsep = None, extsep = '.'

>   ???
E   AttributeError: 'NoneType' object has no attribute 'rfind'

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/genericpath.py:91: AttributeError
_ ERROR at setup of TestWriteSong.TestReadBundle.test_read_altered_tracknumber _

self = <test_Song.TestReadBundle instance at 0x8ff4a6c>
request = <FuncargRequest for <Function 'test_read_altered_tracknumber'>>

    def pytest_funcarg__song(self, request):
        """Dependency Injection: Song"""
        return request.cached_setup(self.setup_song,
                self.teardown_song,
>               scope='class')

test_Song.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FuncargRequest for <Function 'test_read_altered_tracknumber'>>
setup = <bound method TestReadBundle.setup_song of <test_Song.TestReadBundle instance at 0x8ff4a6c>>
teardown = <bound method TestReadBundle.teardown_song of <test_Song.TestReadBundle instance at 0x8ff4a6c>>
scope = 'class', extrakey = None

    def cached_setup(self, setup, teardown=None, scope="module", extrakey=None):
        """ Return a testing resource managed by ``setup`` &
            ``teardown`` calls.  ``scope`` and ``extrakey`` determine when the
            ``teardown`` function will be called so that subsequent calls to
            ``setup`` would recreate the resource.
    
            :arg teardown: function receiving a previously setup resource.
            :arg setup: a no-argument function creating a resource.
            :arg scope: a string value out of ``function``, ``class``, ``module``
                or ``session`` indicating the caching lifecycle of the resource.
            :arg extrakey: added to internal caching key of (funcargname, scope).
            """
        if not hasattr(self.config, '_setupcache'):
            self.config._setupcache = {} # XXX weakref?
        cachekey = (self._currentarg, self._getscopeitem(scope), extrakey)
        cache = self.config._setupcache
        try:
            val = cache[cachekey]
        except KeyError:
>           val = setup()

../lib/python2.7/site-packages/_pytest/python.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_Song.TestReadBundle instance at 0x8ff4a6c>

    def setup_song(self):
        """Setup: Open edited dummy song"""
>       return Song.Song(TestWriteSong.song)

test_Song.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x8ff4b8c>, path = None, fields = None

    def __init__(self, path, fields=None):
        """Instantiate Song object
    
            Requires a filepath for a song file to represent and accepts an
            optional fields parameter for specifying the songs fields. If
            such a dictionary is passed, it will be used exclusively to fill
            the field tag data of the Song instance.
    
            If no additional fields are specified, the Song instance's fields
            will be populated by metadata from the audio file.
    
            Compatible files: flac (*.flac), ogg vorbis (*.ogg)
            """
    
        self.path = path
        self._song_file = None
>       self._connect_to_file()

../Song.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x8ff4b8c>

    def _connect_to_file(self):
        """Opens a file and determines type. File will be opened
            (if compatible) with codec and metadata will be read in.
            """
        def determine_type():
            """Determine codec to use in opening file depending on extension"""
            extension = os.path.splitext(self.path)[-1][1:]
            return Song._supported_filetypes[extension]
    
>       song_type = determine_type()

../Song.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def determine_type():
        """Determine codec to use in opening file depending on extension"""
>       extension = os.path.splitext(self.path)[-1][1:]

../Song.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None

>   ???

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/posixpath.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None, sep = '/', altsep = None, extsep = '.'

>   ???
E   AttributeError: 'NoneType' object has no attribute 'rfind'

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/genericpath.py:91: AttributeError
____ ERROR at setup of TestWriteSong.TestReadBundle.test_read_altered_date _____

self = <test_Song.TestReadBundle instance at 0x8fe594c>
request = <FuncargRequest for <Function 'test_read_altered_date'>>

    def pytest_funcarg__song(self, request):
        """Dependency Injection: Song"""
        return request.cached_setup(self.setup_song,
                self.teardown_song,
>               scope='class')

test_Song.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FuncargRequest for <Function 'test_read_altered_date'>>
setup = <bound method TestReadBundle.setup_song of <test_Song.TestReadBundle instance at 0x8fe594c>>
teardown = <bound method TestReadBundle.teardown_song of <test_Song.TestReadBundle instance at 0x8fe594c>>
scope = 'class', extrakey = None

    def cached_setup(self, setup, teardown=None, scope="module", extrakey=None):
        """ Return a testing resource managed by ``setup`` &
            ``teardown`` calls.  ``scope`` and ``extrakey`` determine when the
            ``teardown`` function will be called so that subsequent calls to
            ``setup`` would recreate the resource.
    
            :arg teardown: function receiving a previously setup resource.
            :arg setup: a no-argument function creating a resource.
            :arg scope: a string value out of ``function``, ``class``, ``module``
                or ``session`` indicating the caching lifecycle of the resource.
            :arg extrakey: added to internal caching key of (funcargname, scope).
            """
        if not hasattr(self.config, '_setupcache'):
            self.config._setupcache = {} # XXX weakref?
        cachekey = (self._currentarg, self._getscopeitem(scope), extrakey)
        cache = self.config._setupcache
        try:
            val = cache[cachekey]
        except KeyError:
>           val = setup()

../lib/python2.7/site-packages/_pytest/python.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_Song.TestReadBundle instance at 0x8fe594c>

    def setup_song(self):
        """Setup: Open edited dummy song"""
>       return Song.Song(TestWriteSong.song)

test_Song.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x8fe5a6c>, path = None, fields = None

    def __init__(self, path, fields=None):
        """Instantiate Song object
    
            Requires a filepath for a song file to represent and accepts an
            optional fields parameter for specifying the songs fields. If
            such a dictionary is passed, it will be used exclusively to fill
            the field tag data of the Song instance.
    
            If no additional fields are specified, the Song instance's fields
            will be populated by metadata from the audio file.
    
            Compatible files: flac (*.flac), ogg vorbis (*.ogg)
            """
    
        self.path = path
        self._song_file = None
>       self._connect_to_file()

../Song.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x8fe5a6c>

    def _connect_to_file(self):
        """Opens a file and determines type. File will be opened
            (if compatible) with codec and metadata will be read in.
            """
        def determine_type():
            """Determine codec to use in opening file depending on extension"""
            extension = os.path.splitext(self.path)[-1][1:]
            return Song._supported_filetypes[extension]
    
>       song_type = determine_type()

../Song.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def determine_type():
        """Determine codec to use in opening file depending on extension"""
>       extension = os.path.splitext(self.path)[-1][1:]

../Song.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None

>   ???

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/posixpath.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None, sep = '/', altsep = None, extsep = '.'

>   ???
E   AttributeError: 'NoneType' object has no attribute 'rfind'

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/genericpath.py:91: AttributeError
____ ERROR at setup of TestWriteSong.TestReadBundle.test_read_altered_genre ____

self = <test_Song.TestReadBundle instance at 0x900038c>
request = <FuncargRequest for <Function 'test_read_altered_genre'>>

    def pytest_funcarg__song(self, request):
        """Dependency Injection: Song"""
        return request.cached_setup(self.setup_song,
                self.teardown_song,
>               scope='class')

test_Song.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FuncargRequest for <Function 'test_read_altered_genre'>>
setup = <bound method TestReadBundle.setup_song of <test_Song.TestReadBundle instance at 0x900038c>>
teardown = <bound method TestReadBundle.teardown_song of <test_Song.TestReadBundle instance at 0x900038c>>
scope = 'class', extrakey = None

    def cached_setup(self, setup, teardown=None, scope="module", extrakey=None):
        """ Return a testing resource managed by ``setup`` &
            ``teardown`` calls.  ``scope`` and ``extrakey`` determine when the
            ``teardown`` function will be called so that subsequent calls to
            ``setup`` would recreate the resource.
    
            :arg teardown: function receiving a previously setup resource.
            :arg setup: a no-argument function creating a resource.
            :arg scope: a string value out of ``function``, ``class``, ``module``
                or ``session`` indicating the caching lifecycle of the resource.
            :arg extrakey: added to internal caching key of (funcargname, scope).
            """
        if not hasattr(self.config, '_setupcache'):
            self.config._setupcache = {} # XXX weakref?
        cachekey = (self._currentarg, self._getscopeitem(scope), extrakey)
        cache = self.config._setupcache
        try:
            val = cache[cachekey]
        except KeyError:
>           val = setup()

../lib/python2.7/site-packages/_pytest/python.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_Song.TestReadBundle instance at 0x900038c>

    def setup_song(self):
        """Setup: Open edited dummy song"""
>       return Song.Song(TestWriteSong.song)

test_Song.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x90004ac>, path = None, fields = None

    def __init__(self, path, fields=None):
        """Instantiate Song object
    
            Requires a filepath for a song file to represent and accepts an
            optional fields parameter for specifying the songs fields. If
            such a dictionary is passed, it will be used exclusively to fill
            the field tag data of the Song instance.
    
            If no additional fields are specified, the Song instance's fields
            will be populated by metadata from the audio file.
    
            Compatible files: flac (*.flac), ogg vorbis (*.ogg)
            """
    
        self.path = path
        self._song_file = None
>       self._connect_to_file()

../Song.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x90004ac>

    def _connect_to_file(self):
        """Opens a file and determines type. File will be opened
            (if compatible) with codec and metadata will be read in.
            """
        def determine_type():
            """Determine codec to use in opening file depending on extension"""
            extension = os.path.splitext(self.path)[-1][1:]
            return Song._supported_filetypes[extension]
    
>       song_type = determine_type()

../Song.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def determine_type():
        """Determine codec to use in opening file depending on extension"""
>       extension = os.path.splitext(self.path)[-1][1:]

../Song.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None

>   ???

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/posixpath.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None, sep = '/', altsep = None, extsep = '.'

>   ???
E   AttributeError: 'NoneType' object has no attribute 'rfind'

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/genericpath.py:91: AttributeError
_______ ERROR at setup of TestWriteSong.TestReadBundle.test_read_length ________

self = <test_Song.TestReadBundle instance at 0x900096c>
request = <FuncargRequest for <Function 'test_read_length'>>

    def pytest_funcarg__song(self, request):
        """Dependency Injection: Song"""
        return request.cached_setup(self.setup_song,
                self.teardown_song,
>               scope='class')

test_Song.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FuncargRequest for <Function 'test_read_length'>>
setup = <bound method TestReadBundle.setup_song of <test_Song.TestReadBundle instance at 0x900096c>>
teardown = <bound method TestReadBundle.teardown_song of <test_Song.TestReadBundle instance at 0x900096c>>
scope = 'class', extrakey = None

    def cached_setup(self, setup, teardown=None, scope="module", extrakey=None):
        """ Return a testing resource managed by ``setup`` &
            ``teardown`` calls.  ``scope`` and ``extrakey`` determine when the
            ``teardown`` function will be called so that subsequent calls to
            ``setup`` would recreate the resource.
    
            :arg teardown: function receiving a previously setup resource.
            :arg setup: a no-argument function creating a resource.
            :arg scope: a string value out of ``function``, ``class``, ``module``
                or ``session`` indicating the caching lifecycle of the resource.
            :arg extrakey: added to internal caching key of (funcargname, scope).
            """
        if not hasattr(self.config, '_setupcache'):
            self.config._setupcache = {} # XXX weakref?
        cachekey = (self._currentarg, self._getscopeitem(scope), extrakey)
        cache = self.config._setupcache
        try:
            val = cache[cachekey]
        except KeyError:
>           val = setup()

../lib/python2.7/site-packages/_pytest/python.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_Song.TestReadBundle instance at 0x900096c>

    def setup_song(self):
        """Setup: Open edited dummy song"""
>       return Song.Song(TestWriteSong.song)

test_Song.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x9000a6c>, path = None, fields = None

    def __init__(self, path, fields=None):
        """Instantiate Song object
    
            Requires a filepath for a song file to represent and accepts an
            optional fields parameter for specifying the songs fields. If
            such a dictionary is passed, it will be used exclusively to fill
            the field tag data of the Song instance.
    
            If no additional fields are specified, the Song instance's fields
            will be populated by metadata from the audio file.
    
            Compatible files: flac (*.flac), ogg vorbis (*.ogg)
            """
    
        self.path = path
        self._song_file = None
>       self._connect_to_file()

../Song.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Song.Song object at 0x9000a6c>

    def _connect_to_file(self):
        """Opens a file and determines type. File will be opened
            (if compatible) with codec and metadata will be read in.
            """
        def determine_type():
            """Determine codec to use in opening file depending on extension"""
            extension = os.path.splitext(self.path)[-1][1:]
            return Song._supported_filetypes[extension]
    
>       song_type = determine_type()

../Song.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def determine_type():
        """Determine codec to use in opening file depending on extension"""
>       extension = os.path.splitext(self.path)[-1][1:]

../Song.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None

>   ???

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/posixpath.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = None, sep = '/', altsep = None, extsep = '.'

>   ???
E   AttributeError: 'NoneType' object has no attribute 'rfind'

/home/ryan/Programming/Python/projects/r3tagger/lib/python2.7/genericpath.py:91: AttributeError
====================== 6 passed, 7 error in 0.33 seconds =======================
